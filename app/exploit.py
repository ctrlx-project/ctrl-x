from pymetasploit3.msfrpc import MsfRpcClient
from pymetasploit3.msfconsole import MsfRpcConsole
from typing import Dict, List
import time

class MSFManagerLegacy:
    def __init__(self):
        """Initializes the attributes of the Metasploit Manager."""
        self.buffer = list()
        self.busy = False
        self.client = MsfRpcClient('IFwJwgwC', port=55552)
        self.console = MsfRpcConsole(self.client, cb=self.read_console)

    def clear_buffer(self):
        """Erases the console buffer."""
        self.buffer = []

    def read_console(self, console_data: dict):
        """Reads the data on the console. This is usually called automatically
        by the console, so there is no need to call it manually.

        Args:
            console_data (dict): The data output by the console.
        """
        self.busy = console_data['busy']
        data = console_data['data'].rstrip().split('\n')
        for line in data:
            self.buffer.append(line)
        self.busy = False

    def search_cve_module(self, cve: str) -> List[Dict]:
        """Gets the name of the module based on the CVE.

        Args:
            cve (str): The name of the CVE to be searched.

        Returns:
            (List[Dict]): A list of findings.
        """
        self.clear_buffer()
        self.busy = True
        self.console.execute(f"search {cve}")
        while self.busy:
            time.sleep(1)
        results = []
        for finding in self.buffer[6:-3]:
            finding = finding.split()
            results.append({
                'name':finding[1],
                'disclosure_date':finding[2],
                'rank':finding[3],
                'check':finding[4],
                'description':finding[5]
            })
        self.clear_buffer()
        return results

    def select_module(self, module: str) -> List[Dict]:
        """Gets the name of the module based on the CVE.

        Args:
            cve (str): The name of the CVE to be searched.

        Returns:
            (List[Dict]): A list of findings.
        """
        self.clear_buffer()
        self.busy = True
        self.console.execute(f"use {module}")
        while self.busy:
            time.sleep(1)
        self.clear_buffer()
    
    def get_options(self) -> dict:
        """Gets the options of the current module.

        Returns:
            (dict): Module options.
        """
        self.clear_buffer()
        self.busy = True
        self.console.execute(f"show options")
        while self.busy:
            time.sleep(1)       
        options = self.parse_console() 
        self.clear_buffer()
        return options

    def parse_console(self) -> dict:
        """Parses the options of the current module.

        Returns:
            (dict): Module options.
        """
        result = {}

        empty_counter = 1

        current_type = ''
        fields = []
        skip = 0
        start_ind = []

        for line in self.buffer:
            if "View the full module info" in line:
                break
            if not line:
                empty_counter += 1
                continue
            if line.strip()[0] == '-':
                start_ind = []
                counter = 0
                ignore = False
                for i in range(len(line)):
                    if line[i] == '-':
                        if not ignore:
                            start_ind.append(i)
                            ignore = True
                    else:
                        ignore = False
                continue
            if skip:
                skip -= 1
                continue
            if line[0:5] == ' '*5:
                continue

            if empty_counter == 2:
                current_type = '_'.join(line.split()[:2]).lower()
                result[current_type] = {}
                result[current_type]['required'] = {}
                result[current_type]['optional'] = {}
                skip = 1
            elif current_type:
                name = line[start_ind[0]:start_ind[1]].strip().lower()
                if len(start_ind) == 2:
                    setting = line[start_ind[1]:].strip()
                    required = 'no'
                if len(start_ind) == 3:
                    setting = line[start_ind[1]:start_ind[2]].strip()
                    required = line[start_ind[2]:].strip().lower()
                if len(start_ind) >= 4:
                    setting = line[start_ind[1]:start_ind[2]].strip()
                    required = line[start_ind[2]:start_ind[3]].strip().lower()
                required = 'required' if required == 'yes' else 'optional'
                result[current_type][required][name] = setting

            empty_counter = 0

        return result
    
    def set_option(self, option_name: str, option_setting: str) -> dict:
        """Sets one of the options of the current module."""
        self.clear_buffer()
        self.busy = True
        self.console.execute(f"set {option_name} {option_setting}")
        while self.busy:
            time.sleep(1)
        print(self.buffer)
        self.clear_buffer()

    def run(self) -> dict:
        """Executes the exploit using the current module."""
        self.clear_buffer()
        self.busy = True
        self.console.execute(f"run")
        while self.busy:
            time.sleep(1)
        print(self.buffer)
        self.clear_buffer()
    
